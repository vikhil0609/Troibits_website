{"ast":null,"code":"var THREE = require('three');\n\nvar Zlib = require('./inflate.min').Zlib;\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nmodule.exports = function () {\n  THREE.FBXLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  Object.assign(THREE.FBXLoader.prototype, {\n    load: function load(url, onLoad, onProgress, onError) {\n      var self = this;\n      var resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n      var loader = new THREE.FileLoader(this.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        try {\n          var scene = self.parse(buffer, resourceDirectory);\n          onLoad(scene);\n        } catch (error) {\n          window.setTimeout(function () {\n            if (onError) onError(error);\n            self.manager.itemError(url);\n          }, 0);\n        }\n      }, onProgress, onError);\n    },\n    parse: function parse(FBXBuffer, resourceDirectory) {\n      var FBXTree;\n\n      if (isFbxFormatBinary(FBXBuffer)) {\n        FBXTree = new BinaryParser().parse(FBXBuffer);\n      } else {\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n\n        if (!isFbxFormatASCII(FBXText)) {\n          throw new Error('THREE.FBXLoader: Unknown format.');\n        }\n\n        if (getFbxVersion(FBXText) < 7000) {\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n        }\n\n        FBXTree = new TextParser().parse(FBXText);\n      } // console.log( FBXTree );\n\n\n      var connections = parseConnections(FBXTree);\n      var images = parseImages(FBXTree);\n      var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n      var materials = parseMaterials(FBXTree, textures, connections);\n      var deformers = parseDeformers(FBXTree, connections);\n      var geometryMap = parseGeometries(FBXTree, connections, deformers);\n      var sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);\n      return sceneGraph;\n    }\n  }); // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n\n  function parseConnections(FBXTree) {\n    var connectionMap = new Map();\n\n    if ('Connections' in FBXTree) {\n      var rawConnections = FBXTree.Connections.connections;\n      rawConnections.forEach(function (rawConnection) {\n        var fromID = rawConnection[0];\n        var toID = rawConnection[1];\n        var relationship = rawConnection[2];\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        var parentRelationship = {\n          ID: toID,\n          relationship: relationship\n        };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        var childRelationship = {\n          ID: fromID,\n          relationship: relationship\n        };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n\n    return connectionMap;\n  } // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n\n\n  function parseImages(FBXTree) {\n    var images = {};\n    var blobs = {};\n\n    if ('Video' in FBXTree.Objects) {\n      var videoNodes = FBXTree.Objects.Video;\n\n      for (var nodeID in videoNodes) {\n        var videoNode = videoNodes[nodeID];\n        var id = parseInt(nodeID);\n        images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\n\n        if ('Content' in videoNode) {\n          var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n          if (arrayBufferContent || base64Content) {\n            var image = parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n\n    for (var id in images) {\n      var filename = images[id];\n      if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n    }\n\n    return images;\n  } // Parse embedded image data in FBXTree.Video.Content\n\n\n  function parseImage(videoNode) {\n    var content = videoNode.Content;\n    var fileName = videoNode.RelativeFilename || videoNode.Filename;\n    var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n    var type;\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp';\n        break;\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg';\n        break;\n\n      case 'png':\n        type = 'image/png';\n        break;\n\n      case 'tif':\n        type = 'image/tiff';\n        break;\n\n      case 'tga':\n        if (typeof THREE.TGALoader !== 'function') {\n          console.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n          return;\n        } else {\n          if (THREE.Loader.Handlers.get('.tga') === null) {\n            THREE.Loader.Handlers.add(/\\.tga$/i, new THREE.TGALoader());\n          }\n\n          type = 'image/tga';\n          break;\n        }\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n      return 'data:' + type + ';base64,' + content;\n    } else {\n      // Binary Format\n      var array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], {\n        type: type\n      }));\n    }\n  } // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n\n\n  function parseTextures(FBXTree, loader, images, connections) {\n    var textureMap = new Map();\n\n    if ('Texture' in FBXTree.Objects) {\n      var textureNodes = FBXTree.Objects.Texture;\n\n      for (var nodeID in textureNodes) {\n        var texture = parseTexture(textureNodes[nodeID], loader, images, connections);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n\n    return textureMap;\n  } // Parse individual node in FBXTree.Objects.Texture\n\n\n  function parseTexture(textureNode, loader, images, connections) {\n    var texture = loadTexture(textureNode, loader, images, connections);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    var wrapModeU = textureNode.WrapModeU;\n    var wrapModeV = textureNode.WrapModeV;\n    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n    if ('Scaling' in textureNode) {\n      var values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n\n    return texture;\n  } // load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\n\n  function loadTexture(textureNode, loader, images, connections) {\n    var fileName;\n    var currentPath = loader.path;\n    var children = connections.get(textureNode.id).children;\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID];\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        loader.setPath(undefined);\n      }\n    }\n\n    var texture;\n\n    if (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {\n      texture = THREE.Loader.Handlers.get('.tga').load(fileName);\n    } else {\n      texture = loader.load(fileName);\n    }\n\n    loader.setPath(currentPath);\n    return texture;\n  } // Parse nodes in FBXTree.Objects.Material\n\n\n  function parseMaterials(FBXTree, textureMap, connections) {\n    var materialMap = new Map();\n\n    if ('Material' in FBXTree.Objects) {\n      var materialNodes = FBXTree.Objects.Material;\n\n      for (var nodeID in materialNodes) {\n        var material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n\n    return materialMap;\n  } // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n\n\n  function parseMaterial(FBXTree, materialNode, textureMap, connections) {\n    var ID = materialNode.id;\n    var name = materialNode.attrName;\n    var type = materialNode.ShadingModel; //Case where FBX wraps shading model in property object.\n\n    if (typeof type === 'object') {\n      type = type.value;\n    } // Ignore unused materials which don't have any connections.\n\n\n    if (!connections.has(ID)) return null;\n    var parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);\n    var material;\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new THREE.MeshPhongMaterial();\n        break;\n\n      case 'lambert':\n        material = new THREE.MeshLambertMaterial();\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new THREE.MeshPhongMaterial({\n          color: 0x3300ff\n        });\n        break;\n    }\n\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  } // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n\n\n  function parseParameters(FBXTree, properties, textureMap, ID, connections) {\n    var parameters = {};\n\n    if (properties.BumpFactor) {\n      parameters.bumpScale = properties.BumpFactor.value;\n    }\n\n    if (properties.Diffuse) {\n      parameters.color = new THREE.Color().fromArray(properties.Diffuse.value);\n    } else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {\n      // The blender exporter exports diffuse here instead of in properties.Diffuse\n      parameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);\n    }\n\n    if (properties.DisplacementFactor) {\n      parameters.displacementScale = properties.DisplacementFactor.value;\n    }\n\n    if (properties.Emissive) {\n      parameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);\n    } else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {\n      // The blender exporter exports emissive color here instead of in properties.Emissive\n      parameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);\n    }\n\n    if (properties.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n    }\n\n    if (properties.Opacity) {\n      parameters.opacity = parseFloat(properties.Opacity.value);\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true;\n    }\n\n    if (properties.ReflectionFactor) {\n      parameters.reflectivity = properties.ReflectionFactor.value;\n    }\n\n    if (properties.Shininess) {\n      parameters.shininess = properties.Shininess.value;\n    }\n\n    if (properties.Specular) {\n      parameters.specular = new THREE.Color().fromArray(properties.Specular.value);\n    } else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in properties.Specular\n      parameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);\n    }\n\n    connections.get(ID).children.forEach(function (child) {\n      var type = child.relationship;\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = textureMap.get(child.ID);\n          break;\n\n        case 'DiffuseColor':\n          parameters.map = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'DisplacementColor':\n          parameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'NormalMap':\n          parameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'ReflectionColor':\n          parameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n          break;\n\n        case 'SpecularColor':\n          parameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'TransparentColor':\n          parameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.transparent = true;\n          break;\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n\n        case 'SpecularFactor': // AKA specularLevel\n\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n          break;\n      }\n    });\n    return parameters;\n  } // get a texture from the textureMap for use by a material.\n\n\n  function getTexture(FBXTree, textureMap, id, connections) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n      id = connections.get(id).children[0].ID;\n    }\n\n    return textureMap.get(id);\n  } // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\n\n  function parseDeformers(FBXTree, connections) {\n    var skeletons = {};\n    var morphTargets = {};\n\n    if ('Deformer' in FBXTree.Objects) {\n      var DeformerNodes = FBXTree.Objects.Deformer;\n\n      for (var nodeID in DeformerNodes) {\n        var deformerNode = DeformerNodes[nodeID];\n        var relationships = connections.get(parseInt(nodeID));\n\n        if (deformerNode.attrType === 'Skin') {\n          var skeleton = parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === 'BlendShape') {\n          var morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);\n          morphTarget.id = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n          morphTarget.parentGeoID = relationships.parents[0].ID;\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets\n    };\n  } // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n\n\n  function parseSkeleton(connections, deformerNodes) {\n    var rawBones = [];\n    connections.children.forEach(function (child) {\n      var boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== 'Cluster') return;\n      var rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transform: new THREE.Matrix4().fromArray(boneNode.Transform.a),\n        transformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),\n        linkMode: boneNode.Mode\n      };\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones: rawBones,\n      bones: []\n    };\n  } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\n\n  function parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {\n    var rawMorphTargets = [];\n\n    for (var i = 0; i < relationships.children.length; i++) {\n      if (i === 8) {\n        console.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');\n        break;\n      }\n\n      var child = relationships.children[i];\n      var morphTargetNode = deformerNodes[child.ID];\n      var rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n      var targetRelationships = connections.get(parseInt(child.ID));\n      targetRelationships.children.forEach(function (child) {\n        if (child.relationship === 'DeformPercent') {\n          // TODO: animation of morph targets is currently unsupported\n          rawMorphTarget.weightCurveID = child.ID; // weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n        } else {\n          rawMorphTarget.geoID = child.ID; // morphGeo = FBXTree.Objects.Geometry[ geoID ];\n        }\n      });\n      rawMorphTargets.push(rawMorphTarget);\n    }\n\n    return rawMorphTargets;\n  } // Parse nodes in FBXTree.Objects.Geometry\n\n\n  function parseGeometries(FBXTree, connections, deformers) {\n    var geometryMap = new Map();\n\n    if ('Geometry' in FBXTree.Objects) {\n      var geoNodes = FBXTree.Objects.Geometry;\n\n      for (var nodeID in geoNodes) {\n        var relationships = connections.get(parseInt(nodeID));\n        var geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n\n    return geometryMap;\n  } // Parse single node in FBXTree.Objects.Geometry\n\n\n  function parseGeometry(FBXTree, relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return parseMeshGeometry(FBXTree, relationships, geoNode, deformers);\n        break;\n\n      case 'NurbsCurve':\n        return parseNurbsGeometry(geoNode);\n        break;\n    }\n  } // Parse single node mesh geometry in FBXTree.Objects.Geometry\n\n\n  function parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {\n    var skeletons = deformers.skeletons;\n    var morphTargets = deformers.morphTargets;\n    var modelNodes = relationships.parents.map(function (parent) {\n      return FBXTree.Objects.Model[parent.ID];\n    }); // don't create geometry if it is not associated with any models\n\n    if (modelNodes.length === 0) return;\n    var skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n      return skeleton;\n    }, null);\n    var morphTarget = relationships.children.reduce(function (morphTarget, child) {\n      if (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n      return morphTarget;\n    }, null);\n    var preTransform = new THREE.Matrix4(); // TODO: if there is more than one model associated with the geometry, AND the models have\n    // different geometric transforms, then this will cause problems\n    // if ( modelNodes.length > 1 ) { }\n    // For now just assume one model and get the preRotations from that\n\n    var modelNode = modelNodes[0];\n\n    if ('GeometricRotation' in modelNode) {\n      var array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      preTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));\n    }\n\n    if ('GeometricTranslation' in modelNode) {\n      preTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));\n    }\n\n    if ('GeometricScaling' in modelNode) {\n      preTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));\n    }\n\n    return genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);\n  } // Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\n\n  function genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {\n    var geo = new THREE.BufferGeometry();\n    if (geoNode.attrName) geo.name = geoNode.attrName;\n    var geoInfo = getGeoInfo(geoNode, skeleton);\n    var buffers = genBuffers(geoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n    preTransform.applyToBufferAttribute(positionAttribute);\n    geo.addAttribute('position', positionAttribute);\n\n    if (buffers.colors.length > 0) {\n      geo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n    }\n\n    if (skeleton) {\n      geo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\n\n      geo.FBX_Deformer = skeleton;\n    }\n\n    if (buffers.normal.length > 0) {\n      var normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n      normalMatrix.applyToBufferAttribute(normalAttribute);\n      geo.addAttribute('normal', normalAttribute);\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      // subsequent uv buffers are called 'uv1', 'uv2', ...\n      var name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\n\n      if (i === 0) {\n        name = 'uv';\n      }\n\n      geo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      var prevMaterialIndex = buffers.materialIndex[0];\n      var startIndex = 0;\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      }); // the loop above doesn't add the last group, do that here.\n\n      if (geo.groups.length > 0) {\n        var lastGroup = geo.groups[geo.groups.length - 1];\n        var lastIndex = lastGroup.start + lastGroup.count;\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      } // case where there are multiple materials but the whole geometry is only\n      // using one of them\n\n\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n\n    addMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);\n    return geo;\n  }\n\n  function getGeoInfo(geoNode, skeleton) {\n    var geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = getColors(geoNode.LayerElementColor[0]);\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      var i = 0;\n\n      while (geoNode.LayerElementUV[i]) {\n        geoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));\n        i++;\n      }\n    }\n\n    geoInfo.weightTable = {};\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n\n    return geoInfo;\n  }\n\n  function genBuffers(geoInfo) {\n    var buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    var polygonIndex = 0;\n    var faceLength = 0;\n    var displayedWeightsWarning = false; // these will hold data for a single face\n\n    var facePositionIndexes = [];\n    var faceNormals = [];\n    var faceColors = [];\n    var faceUVs = [];\n    var faceWeights = [];\n    var faceWeightIndices = [];\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      var endOfFace = false; // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\n        endOfFace = true;\n      }\n\n      var weightIndices = [];\n      var weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n      if (geoInfo.color) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n            displayedWeightsWarning = true;\n          }\n\n          var wIndex = [0, 0, 0, 0];\n          var Weight = [0, 0, 0, 0];\n          weights.forEach(function (weight, weightIndex) {\n            var currentWeight = weight;\n            var currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                var tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        } // if the weight array is shorter than 4 pad with 0s\n\n\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n\n        for (var i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n\n      if (geoInfo.normal) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = [];\n          }\n\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n\n      faceLength++;\n\n      if (endOfFace) {\n        genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n        polygonIndex++;\n        faceLength = 0; // reset arrays for the next face\n\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\n\n  function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    for (var i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0]);\n        buffers.vertexWeights.push(faceWeights[1]);\n        buffers.vertexWeights.push(faceWeights[2]);\n        buffers.vertexWeights.push(faceWeights[3]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i * 4]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[0]);\n        buffers.weightsIndices.push(faceWeightIndices[1]);\n        buffers.weightsIndices.push(faceWeightIndices[2]);\n        buffers.weightsIndices.push(faceWeightIndices[3]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0]);\n        buffers.colors.push(faceColors[1]);\n        buffers.colors.push(faceColors[2]);\n        buffers.colors.push(faceColors[(i - 1) * 3]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n        buffers.colors.push(faceColors[i * 3]);\n        buffers.colors.push(faceColors[i * 3 + 1]);\n        buffers.colors.push(faceColors[i * 3 + 2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0]);\n        buffers.normal.push(faceNormals[1]);\n        buffers.normal.push(faceNormals[2]);\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n        buffers.normal.push(faceNormals[i * 3]);\n        buffers.normal.push(faceNormals[i * 3 + 1]);\n        buffers.normal.push(faceNormals[i * 3 + 2]);\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][0]);\n          buffers.uvs[j].push(faceUVs[j][1]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n        });\n      }\n    }\n  }\n\n  function addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {\n    if (morphTarget === null) return;\n    parentGeo.morphAttributes.position = [];\n    parentGeo.morphAttributes.normal = [];\n    morphTarget.rawTargets.forEach(function (rawTarget) {\n      var morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];\n\n      if (morphGeoNode !== undefined) {\n        genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);\n      }\n    });\n  } // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n\n\n  function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {\n    var morphGeo = new THREE.BufferGeometry();\n    if (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n    var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []; // make a copy of the parent's vertex positions\n\n    var vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n    var morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n    var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n    for (var i = 0; i < indices.length; i++) {\n      var morphIndex = indices[i] * 3; // FBX format uses blend shapes rather than morph targets. This can be converted\n      // by additively combining the blend shape positions with the original geometry's positions\n\n      vertexPositions[morphIndex] += morphPositions[i * 3];\n      vertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n      vertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n    } // TODO: add morph normal support\n\n\n    var morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: vertexPositions\n    };\n    var morphBuffers = genBuffers(morphGeoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = morphGeoNode.attrName;\n    preTransform.applyToBufferAttribute(positionAttribute);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\n\n  function getNormals(NormalNode) {\n    var mappingType = NormalNode.MappingInformationType;\n    var referenceType = NormalNode.ReferenceInformationType;\n    var buffer = NormalNode.Normals.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\n\n  function getUVs(UVNode) {\n    var mappingType = UVNode.MappingInformationType;\n    var referenceType = UVNode.ReferenceInformationType;\n    var buffer = UVNode.UV.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\n\n  function getColors(ColorNode) {\n    var mappingType = ColorNode.MappingInformationType;\n    var referenceType = ColorNode.ReferenceInformationType;\n    var buffer = ColorNode.Colors.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\n\n  function getMaterials(MaterialNode) {\n    var mappingType = MaterialNode.MappingInformationType;\n    var referenceType = MaterialNode.ReferenceInformationType;\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n    }\n\n    var materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n\n    var materialIndices = [];\n\n    for (var i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n\n  var dataArray = [];\n\n  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n    var index;\n\n    switch (infoObject.mappingType) {\n      case 'ByPolygonVertex':\n        index = polygonVertexIndex;\n        break;\n\n      case 'ByPolygon':\n        index = polygonIndex;\n        break;\n\n      case 'ByVertice':\n        index = vertexIndex;\n        break;\n\n      case 'AllSame':\n        index = infoObject.indices[0];\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n    }\n\n    if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n    var from = index * infoObject.dataSize;\n    var to = from + infoObject.dataSize;\n    return slice(dataArray, infoObject.buffer, from, to);\n  } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\n\n  function parseNurbsGeometry(geoNode) {\n    if (THREE.NURBSCurve === undefined) {\n      console.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n      return new THREE.BufferGeometry();\n    }\n\n    var order = parseInt(geoNode.Order);\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n      return new THREE.BufferGeometry();\n    }\n\n    var degree = order - 1;\n    var knots = geoNode.KnotVector.a;\n    var controlPoints = [];\n    var pointsValues = geoNode.Points.a;\n\n    for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n    }\n\n    var startKnot, endKnot;\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n\n      for (var i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n\n    var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    var vertices = curve.getPoints(controlPoints.length * 7);\n    var positions = new Float32Array(vertices.length * 3);\n    vertices.forEach(function (vertex, i) {\n      vertex.toArray(positions, i * 3);\n    });\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n    return geometry;\n  } // create the main THREE.Group() to be returned by the loader\n\n\n  function parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {\n    var sceneGraph = new THREE.Group();\n    var modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);\n    var modelNodes = FBXTree.Objects.Model;\n    modelMap.forEach(function (model) {\n      var modelNode = modelNodes[model.ID];\n      setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);\n      var parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function (connection) {\n        var parent = modelMap.get(connection.ID);\n        if (parent !== undefined) parent.add(model);\n      });\n\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);\n    addAnimations(FBXTree, connections, sceneGraph);\n    createAmbientLight(FBXTree, sceneGraph);\n    return sceneGraph;\n  } // parse nodes in FBXTree.Objects.Model\n\n\n  function parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {\n    var modelMap = new Map();\n    var modelNodes = FBXTree.Objects.Model;\n\n    for (var nodeID in modelNodes) {\n      var id = parseInt(nodeID);\n      var node = modelNodes[nodeID];\n      var relationships = connections.get(id);\n      var model = buildSkeleton(relationships, skeletons, id, node.attrName);\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = createCamera(FBXTree, relationships);\n            break;\n\n          case 'Light':\n            model = createLight(FBXTree, relationships);\n            break;\n\n          case 'Mesh':\n            model = createMesh(FBXTree, relationships, geometryMap, materialMap);\n            break;\n\n          case 'NurbsCurve':\n            model = createCurve(relationships, geometryMap);\n            break;\n\n          case 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\n          case 'Null':\n          default:\n            model = new THREE.Group();\n            break;\n        }\n\n        model.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n        model.ID = id;\n      }\n\n      setModelTransforms(FBXTree, model, node);\n      modelMap.set(id, model);\n    }\n\n    return modelMap;\n  }\n\n  function buildSkeleton(relationships, skeletons, id, name) {\n    var bone = null;\n    relationships.parents.forEach(function (parent) {\n      for (var ID in skeletons) {\n        var skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            var subBone = bone;\n            bone = new THREE.Bone();\n            bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n            bone.ID = id;\n            skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  } // create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\n\n  function createCamera(FBXTree, relationships) {\n    var model;\n    var cameraAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        cameraAttribute = attr;\n      }\n    });\n\n    if (cameraAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type = 0;\n\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n\n      var nearClippingPlane = 1;\n\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n      }\n\n      var farClippingPlane = 1000;\n\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n      }\n\n      var width = window.innerWidth;\n      var height = window.innerHeight;\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n\n      var aspect = width / height;\n      var fov = 45;\n\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value;\n      }\n\n      var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n      switch (type) {\n        case 0:\n          // Perspective\n          model = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null) model.setFocalLength(focalLength);\n          break;\n\n        case 1:\n          // Orthographic\n          model = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n          model = new THREE.Object3D();\n          break;\n      }\n    }\n\n    return model;\n  } // Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\n\n  function createLight(FBXTree, relationships) {\n    var model;\n    var lightAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        lightAttribute = attr;\n      }\n    });\n\n    if (lightAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type; // LightType can be undefined for Point lights\n\n      if (lightAttribute.LightType === undefined) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n\n      var color = 0xffffff;\n\n      if (lightAttribute.Color !== undefined) {\n        color = new THREE.Color().fromArray(lightAttribute.Color.value);\n      }\n\n      var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\n\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n\n      var distance = 0;\n\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\n\n      var decay = 1;\n\n      switch (type) {\n        case 0:\n          // Point\n          model = new THREE.PointLight(color, intensity, distance, decay);\n          break;\n\n        case 1:\n          // Directional\n          model = new THREE.DirectionalLight(color, intensity);\n          break;\n\n        case 2:\n          // Spot\n          var angle = Math.PI / 3;\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n          }\n\n          var penumbra = 0;\n\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n\n          model = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n          model = new THREE.PointLight(color, intensity);\n          break;\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n\n    return model;\n  }\n\n  function createMesh(FBXTree, relationships, geometryMap, materialMap) {\n    var model;\n    var geometry = null;\n    var material = null;\n    var materials = []; // get geometry and materials(s) from connections\n\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new THREE.MeshPhongMaterial({\n        color: 0xcccccc\n      });\n      materials.push(material);\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = THREE.VertexColors;\n      });\n    }\n\n    if (geometry.FBX_Deformer) {\n      materials.forEach(function (material) {\n        material.skinning = true;\n      });\n      model = new THREE.SkinnedMesh(geometry, material);\n    } else {\n      model = new THREE.Mesh(geometry, material);\n    }\n\n    return model;\n  }\n\n  function createCurve(relationships, geometryMap) {\n    var geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n      return geo;\n    }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\n    var material = new THREE.LineBasicMaterial({\n      color: 0x3300ff,\n      linewidth: 1\n    });\n    return new THREE.Line(geometry, material);\n  } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\n\n  function createAmbientLight(FBXTree, sceneGraph) {\n    if ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {\n      var ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n      var r = ambientColor[0];\n      var g = ambientColor[1];\n      var b = ambientColor[2];\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        var color = new THREE.Color(r, g, b);\n        sceneGraph.add(new THREE.AmbientLight(color, 1));\n      }\n    }\n  }\n\n  function setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {\n    if ('LookAtProperty' in modelNode) {\n      var children = connections.get(model.ID).children;\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          var lookAtTarget = FBXTree.Objects.Model[child.ID];\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            var pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\n\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              // Cameras and other Object3Ds\n              model.lookAt(new THREE.Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  } // parse the model node for transform details and apply them to the model\n\n\n  function setModelTransforms(FBXTree, model, modelNode) {\n    // http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n    if ('RotationOrder' in modelNode) {\n      var enums = ['XYZ', // default\n      'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];\n      var value = parseInt(modelNode.RotationOrder.value, 10);\n\n      if (value > 0 && value < 6) {\n        // model.rotation.order = enums[ value ];\n        // Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n        console.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);\n      } else if (value === 6) {\n        console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n      }\n    }\n\n    if ('Lcl_Translation' in modelNode) {\n      model.position.fromArray(modelNode.Lcl_Translation.value);\n    }\n\n    if ('Lcl_Rotation' in modelNode) {\n      var rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);\n      rotation.push('ZYX');\n      model.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));\n    }\n\n    if ('Lcl_Scaling' in modelNode) {\n      model.scale.fromArray(modelNode.Lcl_Scaling.value);\n    }\n\n    if ('PreRotation' in modelNode) {\n      var array = modelNode.PreRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      var preRotations = new THREE.Euler().fromArray(array);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n      model.quaternion.premultiply(preRotations);\n    }\n  }\n\n  function bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {\n    var bindMatrices = parsePoseNodes(FBXTree);\n\n    for (var ID in skeletons) {\n      var skeleton = skeletons[ID];\n      var parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          var geoID = parent.ID;\n          var geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              var model = modelMap.get(geoConnParent.ID);\n              model.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  function parsePoseNodes(FBXTree) {\n    var bindMatrices = {};\n\n    if ('Pose' in FBXTree.Objects) {\n      var BindPoseNode = FBXTree.Objects.Pose;\n\n      for (var nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose') {\n          var poseNodes = BindPoseNode[nodeID].PoseNode;\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n\n    return bindMatrices;\n  }\n\n  function parseAnimations(FBXTree, connections) {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (FBXTree.Objects.AnimationCurve === undefined) return undefined;\n    var curveNodesMap = parseAnimationCurveNodes(FBXTree);\n    parseAnimationCurves(FBXTree, connections, curveNodesMap);\n    var layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);\n    var rawClips = parseAnimStacks(FBXTree, connections, layersMap);\n    return rawClips;\n  } // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n\n\n  function parseAnimationCurveNodes(FBXTree) {\n    var rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n    var curveNodesMap = new Map();\n\n    for (var nodeID in rawCurveNodes) {\n      var rawCurveNode = rawCurveNodes[nodeID];\n\n      if (rawCurveNode.attrName.match(/S|R|T/) !== null) {\n        var curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n\n    return curveNodesMap;\n  } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n\n\n  function parseAnimationCurves(FBXTree, connections, curveNodesMap) {\n    var rawCurves = FBXTree.Objects.AnimationCurve;\n\n    for (var nodeID in rawCurves) {\n      var animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      var relationships = connections.get(animationCurve.id);\n\n      if (relationships !== undefined) {\n        var animationCurveID = relationships.parents[0].ID;\n        var animationCurveRelationship = relationships.parents[0].relationship;\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n        }\n      }\n    }\n  } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\n\n  function parseAnimationLayers(FBXTree, connections, curveNodesMap) {\n    var rawLayers = FBXTree.Objects.AnimationLayer;\n    var layersMap = new Map();\n\n    for (var nodeID in rawLayers) {\n      var layerCurveNodes = [];\n      var connection = connections.get(parseInt(nodeID));\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        var children = connection.children;\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            var curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\n            if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                var modelID;\n                connections.get(child.ID).parents.forEach(function (parent) {\n                  if (parent.relationship !== undefined) modelID = parent.ID;\n                });\n                var rawModel = FBXTree.Objects.Model[modelID.toString()];\n                var node = {\n                  modelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n                  initialPosition: [0, 0, 0],\n                  initialRotation: [0, 0, 0],\n                  initialScale: [1, 1, 1]\n                };\n                if ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;\n                if ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;\n                if ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value; // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                // animation value as well\n\n                if ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;\n                layerCurveNodes[i] = node;\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n\n    return layersMap;\n  } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\n\n  function parseAnimStacks(FBXTree, connections, layersMap) {\n    var rawStacks = FBXTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\n\n    var rawClips = {};\n\n    for (var nodeID in rawStacks) {\n      var children = connections.get(parseInt(nodeID)).children;\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n      }\n\n      var layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer\n      };\n    }\n\n    return rawClips;\n  } // take raw animation data from parseAnimations and connect it up to the loaded models\n\n\n  function addAnimations(FBXTree, connections, sceneGraph) {\n    sceneGraph.animations = [];\n    var rawClips = parseAnimations(FBXTree, connections);\n    if (rawClips === undefined) return;\n\n    for (var key in rawClips) {\n      var rawClip = rawClips[key];\n      var clip = addClip(rawClip);\n      sceneGraph.animations.push(clip);\n    }\n  }\n\n  function addClip(rawClip) {\n    var tracks = [];\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(generateTracks(rawTracks));\n    });\n    return new THREE.AnimationClip(rawClip.name, -1, tracks);\n  }\n\n  function generateTracks(rawTracks) {\n    var tracks = [];\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      var positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');\n      if (positionTrack !== undefined) tracks.push(positionTrack);\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      var rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);\n      if (rotationTrack !== undefined) tracks.push(rotationTrack);\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      var scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');\n      if (scaleTrack !== undefined) tracks.push(scaleTrack);\n    }\n\n    return tracks;\n  }\n\n  function generateVectorTrack(modelName, curves, initialValue, type) {\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n    return new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n  }\n\n  function generateRotationTrack(modelName, curves, initialValue, preRotations) {\n    if (curves.x !== undefined) {\n      interpolateRotations(curves.x);\n      curves.x.values = curves.x.values.map(THREE.Math.degToRad);\n    }\n\n    if (curves.y !== undefined) {\n      interpolateRotations(curves.y);\n      curves.y.values = curves.y.values.map(THREE.Math.degToRad);\n    }\n\n    if (curves.z !== undefined) {\n      interpolateRotations(curves.z);\n      curves.z.values = curves.z.values.map(THREE.Math.degToRad);\n    }\n\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n\n    if (preRotations !== undefined) {\n      preRotations = preRotations.map(THREE.Math.degToRad);\n      preRotations.push('ZYX');\n      preRotations = new THREE.Euler().fromArray(preRotations);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n    }\n\n    var quaternion = new THREE.Quaternion();\n    var euler = new THREE.Euler();\n    var quaternionValues = [];\n\n    for (var i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], 'ZYX');\n      quaternion.setFromEuler(euler);\n      if (preRotations !== undefined) quaternion.premultiply(preRotations);\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n\n    return new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n  }\n\n  function getKeyframeTrackValues(times, curves, initialValue) {\n    var prevValue = initialValue;\n    var values = [];\n    var xIndex = -1;\n    var yIndex = -1;\n    var zIndex = -1;\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\n      if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\n\n      if (xIndex !== -1) {\n        var xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0]);\n      }\n\n      if (yIndex !== -1) {\n        var yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n\n      if (zIndex !== -1) {\n        var zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  } // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n\n\n  function getTimesForAllAxes(curves) {\n    var times = []; // first join together the times for each axis, if defined\n\n    if (curves.x !== undefined) times = times.concat(curves.x.times);\n    if (curves.y !== undefined) times = times.concat(curves.y.times);\n    if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them and remove duplicates\n\n    times = times.sort(function (a, b) {\n      return a - b;\n    }).filter(function (elem, index, array) {\n      return array.indexOf(elem) == index;\n    });\n    return times;\n  } // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n\n\n  function interpolateRotations(curve) {\n    for (var i = 1; i < curve.values.length; i++) {\n      var initialValue = curve.values[i - 1];\n      var valuesSpan = curve.values[i] - initialValue;\n      var absoluteSpan = Math.abs(valuesSpan);\n\n      if (absoluteSpan >= 180) {\n        var numSubIntervals = absoluteSpan / 180;\n        var step = valuesSpan / numSubIntervals;\n        var nextValue = initialValue + step;\n        var initialTime = curve.times[i - 1];\n        var timeSpan = curve.times[i] - initialTime;\n        var interval = timeSpan / numSubIntervals;\n        var nextTime = initialTime + interval;\n        var interpolatedTimes = [];\n        var interpolatedValues = [];\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime);\n          nextTime += interval;\n          interpolatedValues.push(nextValue);\n          nextValue += step;\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes);\n        curve.values = inject(curve.values, i, interpolatedValues);\n      }\n    }\n  } // parse an FBX file in ASCII format\n\n\n  function TextParser() {}\n\n  Object.assign(TextParser.prototype, {\n    getPrevNode: function getPrevNode() {\n      return this.nodeStack[this.currentIndent - 2];\n    },\n    getCurrentNode: function getCurrentNode() {\n      return this.nodeStack[this.currentIndent - 1];\n    },\n    getCurrentProp: function getCurrentProp() {\n      return this.currentProp;\n    },\n    pushStack: function pushStack(node) {\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n    },\n    popStack: function popStack() {\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n    },\n    setCurrentProp: function setCurrentProp(val, name) {\n      this.currentProp = val;\n      this.currentPropName = name;\n    },\n    parse: function parse(text) {\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n      var self = this;\n      var split = text.split('\\n');\n      split.forEach(function (line, i) {\n        var matchComment = line.match(/^[\\s\\t]*;/);\n        var matchEmpty = line.match(/^[\\s\\t]*$/);\n        if (matchComment || matchEmpty) return;\n        var matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n        var matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n        var matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n\n        if (matchBeginning) {\n          self.parseNodeBegin(line, matchBeginning);\n        } else if (matchProperty) {\n          self.parseNodeProperty(line, matchProperty, split[++i]);\n        } else if (matchEnd) {\n          self.popStack();\n        } else if (line.match(/^[^\\s\\t}]/)) {\n          // large arrays are split over multiple lines terminated with a ',' character\n          // if this is encountered the line needs to be joined to the previous line\n          self.parseNodePropertyContinued(line);\n        }\n      });\n      return this.allNodes;\n    },\n    parseNodeBegin: function parseNodeBegin(line, property) {\n      var nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n      var nodeAttrs = property[2].split(',').map(function (attr) {\n        return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n      });\n      var node = {\n        name: nodeName\n      };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode(); // a top node\n\n      if (this.currentIndent === 0) {\n        this.allNodes.add(nodeName, node);\n      } else {\n        // a subnode\n        // if the subnode already exists, append it\n        if (nodeName in currentNode) {\n          // special case Pose needs PoseNodes as an array\n          if (nodeName === 'PoseNode') {\n            currentNode.PoseNode.push(node);\n          } else if (currentNode[nodeName].id !== undefined) {\n            currentNode[nodeName] = {};\n            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n          }\n\n          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n        } else if (typeof attrs.id === 'number') {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][attrs.id] = node;\n        } else if (nodeName !== 'Properties70') {\n          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n        }\n      }\n\n      if (typeof attrs.id === 'number') node.id = attrs.id;\n      if (attrs.name !== '') node.attrName = attrs.name;\n      if (attrs.type !== '') node.attrType = attrs.type;\n      this.pushStack(node);\n    },\n    parseNodeAttr: function parseNodeAttr(attrs) {\n      var id = attrs[0];\n\n      if (attrs[0] !== '') {\n        id = parseInt(attrs[0]);\n\n        if (isNaN(id)) {\n          id = attrs[0];\n        }\n      }\n\n      var name = '',\n          type = '';\n\n      if (attrs.length > 1) {\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n      }\n\n      return {\n        id: id,\n        name: name,\n        type: type\n      };\n    },\n    parseNodeProperty: function parseNodeProperty(line, property, contentLine) {\n      var propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n      var propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\n      //\tContent: ,\n      //\t \"/9j/4RDaRXhpZgAATU0A...\"\n\n      if (propName === 'Content' && propValue === ',') {\n        propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n      }\n\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name;\n\n      if (parentName === 'Properties70') {\n        this.parseNodeSpecialProperty(line, propName, propValue);\n        return;\n      } // Connections\n\n\n      if (propName === 'C') {\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n        var rest = propValue.split(',').slice(3);\n        rest = rest.map(function (elem) {\n          return elem.trim().replace(/^\"/, '');\n        });\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n\n        if (currentNode[propName] === undefined) {\n          currentNode[propName] = [];\n        }\n      } // Node\n\n\n      if (propName === 'Node') currentNode.id = propValue; // connections\n\n      if (propName in currentNode && Array.isArray(currentNode[propName])) {\n        currentNode[propName].push(propValue);\n      } else {\n        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n      }\n\n      this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\n\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(propValue);\n      }\n    },\n    parseNodePropertyContinued: function parseNodePropertyContinued(line) {\n      var currentNode = this.getCurrentNode();\n      currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\n      // so convert the string to an array\n\n      if (line.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(currentNode.a);\n      }\n    },\n    // parse \"Property70\"\n    parseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",').map(function (prop) {\n        return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      });\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\n\n      switch (innerPropType1) {\n        case 'int':\n        case 'enum':\n        case 'bool':\n        case 'ULongLong':\n        case 'double':\n        case 'Number':\n        case 'FieldOfView':\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n\n        case 'Color':\n        case 'ColorRGB':\n        case 'Vector3D':\n        case 'Lcl_Translation':\n        case 'Lcl_Rotation':\n        case 'Lcl_Scaling':\n          innerPropValue = parseNumberArray(innerPropValue);\n          break;\n      } // CAUTION: these props must append to parent's parent\n\n\n      this.getPrevNode()[innerPropName] = {\n        'type': innerPropType1,\n        'type2': innerPropType2,\n        'flag': innerPropFlag,\n        'value': innerPropValue\n      };\n      this.setCurrentProp(this.getPrevNode(), innerPropName);\n    }\n  }); // Parse an FBX file in Binary format\n\n  function BinaryParser() {}\n\n  Object.assign(BinaryParser.prototype, {\n    parse: function parse(buffer) {\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32();\n      console.log('THREE.FBXLoader: FBX binary version: ' + version);\n      var allNodes = new FBXTree();\n\n      while (!this.endOfContent(reader)) {\n        var node = this.parseNode(reader, version);\n        if (node !== null) allNodes.add(node.name, node);\n      }\n\n      return allNodes;\n    },\n    // Check if reader has reached the end of content.\n    endOfContent: function endOfContent(reader) {\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //\t(seems like some exporters embed fixed 15 or 16bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n      } else {\n        return reader.getOffset() + 160 + 16 >= reader.size();\n      }\n    },\n    // recursively parse nodes until the end of the file is reached\n    parseNode: function parseNode(reader, version) {\n      var node = {}; // The first three data sizes depends on version.\n\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32(); // note: do not remove this even if you get a linter warning as it moves the buffer forward\n\n      var propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\n\n      if (endOffset === 0) return null;\n      var propertyList = [];\n\n      for (var i = 0; i < numProperties; i++) {\n        propertyList.push(this.parseProperty(reader));\n      } // Regards the first three elements in propertyList as id, attrName, and attrType\n\n\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\n      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n      while (endOffset > reader.getOffset()) {\n        var subNode = this.parseNode(reader, version);\n        if (subNode !== null) this.parseSubNode(name, node, subNode);\n      }\n\n      node.propertyList = propertyList; // raw property list used by parent\n\n      if (typeof id === 'number') node.id = id;\n      if (attrName !== '') node.attrName = attrName;\n      if (attrType !== '') node.attrType = attrType;\n      if (name !== '') node.name = name;\n      return node;\n    },\n    parseSubNode: function parseSubNode(name, node, subNode) {\n      // special case: child node is single property\n      if (subNode.singleProperty === true) {\n        var value = subNode.propertyList[0];\n\n        if (Array.isArray(value)) {\n          node[subNode.name] = subNode;\n          subNode.a = value;\n        } else {\n          node[subNode.name] = value;\n        }\n      } else if (name === 'Connections' && subNode.name === 'C') {\n        var array = [];\n        subNode.propertyList.forEach(function (property, i) {\n          // first Connection is FBX type (OO, OP, etc.). We'll discard these\n          if (i !== 0) array.push(property);\n        });\n\n        if (node.connections === undefined) {\n          node.connections = [];\n        }\n\n        node.connections.push(array);\n      } else if (subNode.name === 'Properties70') {\n        var keys = Object.keys(subNode);\n        keys.forEach(function (key) {\n          node[key] = subNode[key];\n        });\n      } else if (name === 'Properties70' && subNode.name === 'P') {\n        var innerPropName = subNode.propertyList[0];\n        var innerPropType1 = subNode.propertyList[1];\n        var innerPropType2 = subNode.propertyList[2];\n        var innerPropFlag = subNode.propertyList[3];\n        var innerPropValue;\n        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n        } else {\n          innerPropValue = subNode.propertyList[4];\n        } // this will be copied to parent, see above\n\n\n        node[innerPropName] = {\n          'type': innerPropType1,\n          'type2': innerPropType2,\n          'flag': innerPropFlag,\n          'value': innerPropValue\n        };\n      } else if (node[subNode.name] === undefined) {\n        if (typeof subNode.id === 'number') {\n          node[subNode.name] = {};\n          node[subNode.name][subNode.id] = subNode;\n        } else {\n          node[subNode.name] = subNode;\n        }\n      } else {\n        if (subNode.name === 'PoseNode') {\n          if (!Array.isArray(node[subNode.name])) {\n            node[subNode.name] = [node[subNode.name]];\n          }\n\n          node[subNode.name].push(subNode);\n        } else if (node[subNode.name][subNode.id] === undefined) {\n          node[subNode.name][subNode.id] = subNode;\n        }\n      }\n    },\n    parseProperty: function parseProperty(reader) {\n      var type = reader.getString(1);\n\n      switch (type) {\n        case 'C':\n          return reader.getBoolean();\n\n        case 'D':\n          return reader.getFloat64();\n\n        case 'F':\n          return reader.getFloat32();\n\n        case 'I':\n          return reader.getInt32();\n\n        case 'L':\n          return reader.getInt64();\n\n        case 'R':\n          var length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n\n        case 'S':\n          var length = reader.getUint32();\n          return reader.getString(length);\n\n        case 'Y':\n          return reader.getInt16();\n\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'f':\n        case 'i':\n        case 'l':\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\n          var compressedLength = reader.getUint32();\n\n          if (encoding === 0) {\n            switch (type) {\n              case 'b':\n              case 'c':\n                return reader.getBooleanArray(arrayLength);\n\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n            }\n          }\n\n          var inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\n          var reader2 = new BinaryReader(inflate.decompress().buffer);\n\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader2.getBooleanArray(arrayLength);\n\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n          }\n\n        default:\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n      }\n    }\n  });\n\n  function BinaryReader(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n\n  Object.assign(BinaryReader.prototype, {\n    getOffset: function getOffset() {\n      return this.offset;\n    },\n    size: function size() {\n      return this.dv.buffer.byteLength;\n    },\n    skip: function skip(length) {\n      this.offset += length;\n    },\n    // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean: function getBoolean() {\n      return (this.getUint8() & 1) === 1;\n    },\n    getBooleanArray: function getBooleanArray(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getBoolean());\n      }\n\n      return a;\n    },\n    getUint8: function getUint8() {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    },\n    getInt16: function getInt16() {\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    },\n    getInt32: function getInt32() {\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getInt32Array: function getInt32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt32());\n      }\n\n      return a;\n    },\n    getUint32: function getUint32() {\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64: function getInt64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      } // calculate negative value\n\n\n      if (high & 0x80000000) {\n        high = ~high & 0xFFFFFFFF;\n        low = ~low & 0xFFFFFFFF;\n        if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n        low = low + 1 & 0xFFFFFFFF;\n        return -(high * 0x100000000 + low);\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getInt64Array: function getInt64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt64());\n      }\n\n      return a;\n    },\n    // Note: see getInt64() comment\n    getUint64: function getUint64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getFloat32: function getFloat32() {\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getFloat32Array: function getFloat32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n\n      return a;\n    },\n    getFloat64: function getFloat64() {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    },\n    getFloat64Array: function getFloat64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n\n      return a;\n    },\n    getArrayBuffer: function getArrayBuffer(size) {\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n    },\n    getString: function getString(size) {\n      var a = new Uint8Array(size);\n\n      for (var i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n\n      var nullByte = a.indexOf(0);\n      if (nullByte >= 0) a = a.slice(0, nullByte);\n      return THREE.LoaderUtils.decodeText(a);\n    }\n  }); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n  // and BinaryParser( FBX Binary format)\n\n  function FBXTree() {}\n\n  Object.assign(FBXTree.prototype, {\n    add: function add(key, val) {\n      this[key] = val;\n    }\n  });\n\n  function isFbxFormatBinary(buffer) {\n    var CORRECT = 'Kaydara FBX Binary  \\0';\n    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n  }\n\n  function isFbxFormatASCII(text) {\n    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n    var cursor = 0;\n\n    function read(offset) {\n      var result = text[offset - 1];\n      text = text.slice(cursor + offset);\n      cursor++;\n      return result;\n    }\n\n    for (var i = 0; i < CORRECT.length; ++i) {\n      var num = read(1);\n\n      if (num === CORRECT[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getFbxVersion(text) {\n    var versionRegExp = /FBXVersion: (\\d+)/;\n    var match = text.match(versionRegExp);\n\n    if (match) {\n      var version = parseInt(match[1]);\n      return version;\n    }\n\n    throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n  } // Converts FBX ticks into real time seconds.\n\n\n  function convertFBXTimeToSeconds(time) {\n    return time / 46186158000;\n  } // Parses comma separated list of numbers and returns them an array.\n  // Used internally by the TextParser\n\n\n  function parseNumberArray(value) {\n    var array = value.split(',').map(function (val) {\n      return parseFloat(val);\n    });\n    return array;\n  }\n\n  function convertArrayBufferToString(buffer, from, to) {\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n    return THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n  }\n\n  function append(a, b) {\n    for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n      a[j] = b[i];\n    }\n  }\n\n  function slice(a, b, from, to) {\n    for (var i = from, j = 0; i < to; i++, j++) {\n      a[j] = b[i];\n    }\n\n    return a;\n  } // inject array a2 into array a1 at index\n\n\n  function inject(a1, index, a2) {\n    return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n  }\n\n  return THREE.FBXLoader;\n}();","map":{"version":3,"sources":["/Users/vikhil/Desktop/Troibits_website/node_modules/three-fbxloader-offical/index.js"],"names":["THREE","require","Zlib","module","exports","FBXLoader","manager","undefined","DefaultLoadingManager","Object","assign","prototype","load","url","onLoad","onProgress","onError","self","resourceDirectory","LoaderUtils","extractUrlBase","loader","FileLoader","setResponseType","buffer","scene","parse","error","window","setTimeout","itemError","FBXBuffer","FBXTree","isFbxFormatBinary","BinaryParser","FBXText","convertArrayBufferToString","isFbxFormatASCII","Error","getFbxVersion","TextParser","connections","parseConnections","images","parseImages","textures","parseTextures","TextureLoader","setPath","materials","parseMaterials","deformers","parseDeformers","geometryMap","parseGeometries","sceneGraph","parseScene","skeletons","connectionMap","Map","rawConnections","Connections","forEach","rawConnection","fromID","toID","relationship","has","set","parents","children","parentRelationship","ID","get","push","childRelationship","blobs","Objects","videoNodes","Video","nodeID","videoNode","id","parseInt","RelativeFilename","Filename","arrayBufferContent","Content","ArrayBuffer","byteLength","base64Content","image","parseImage","filename","split","pop","content","fileName","extension","slice","lastIndexOf","toLowerCase","type","TGALoader","console","warn","Loader","Handlers","add","array","Uint8Array","URL","createObjectURL","Blob","textureMap","textureNodes","Texture","texture","parseTexture","textureNode","loadTexture","name","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","value","valueV","wrapS","RepeatWrapping","ClampToEdgeWrapping","wrapT","values","Scaling","repeat","x","y","currentPath","path","length","indexOf","FileName","materialMap","materialNodes","Material","material","parseMaterial","materialNode","ShadingModel","parameters","parseParameters","MeshPhongMaterial","MeshLambertMaterial","color","setValues","properties","BumpFactor","bumpScale","Diffuse","Color","fromArray","DiffuseColor","DisplacementFactor","displacementScale","Emissive","emissive","EmissiveColor","EmissiveFactor","emissiveIntensity","parseFloat","Opacity","opacity","transparent","ReflectionFactor","reflectivity","Shininess","shininess","Specular","specular","SpecularColor","child","bumpMap","map","getTexture","displacementMap","emissiveMap","normalMap","envMap","mapping","EquirectangularReflectionMapping","specularMap","alphaMap","LayeredTexture","morphTargets","DeformerNodes","Deformer","deformerNode","relationships","attrType","skeleton","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","parentGeoID","deformerNodes","rawBones","boneNode","rawBone","indices","weights","transform","Matrix4","Transform","a","transformLink","TransformLink","linkMode","Mode","Indexes","Weights","bones","rawMorphTargets","i","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","targetRelationships","weightCurveID","geoID","geoNodes","Geometry","geo","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","modelNodes","parent","Model","reduce","preTransform","modelNode","GeometricRotation","Math","degToRad","makeRotationFromEuler","Euler","setPosition","Vector3","GeometricTranslation","scale","GeometricScaling","genGeometry","BufferGeometry","geoInfo","getGeoInfo","buffers","genBuffers","positionAttribute","Float32BufferAttribute","vertex","applyToBufferAttribute","addAttribute","colors","Uint16BufferAttribute","weightsIndices","vertexWeights","FBX_Deformer","normal","normalAttribute","normalMatrix","Matrix3","getNormalMatrix","uvs","uvBuffer","toString","mappingType","prevMaterialIndex","materialIndex","startIndex","currentIndex","addGroup","groups","lastGroup","lastIndex","start","count","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","getColors","LayerElementMaterial","getMaterials","LayerElementNormal","getNormals","LayerElementUV","uv","getUVs","weightTable","index","j","weight","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","data","getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","genFace","parentGeo","parentGeoNode","morphAttributes","position","rawTarget","morphGeoNode","genMorphGeometry","morphGeo","morphPositions","morphIndex","morphGeoInfo","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UV","UVIndex","ColorNode","Colors","ColorIndex","MaterialNode","materialIndexBuffer","Materials","materialIndices","dataArray","infoObject","from","to","NURBSCurve","order","Order","isNaN","degree","knots","KnotVector","controlPoints","pointsValues","Points","l","Vector4","startKnot","endKnot","Form","curve","vertices","getPoints","positions","Float32Array","toArray","geometry","BufferAttribute","Group","modelMap","parseModels","model","setLookAtProperties","parentConnections","connection","bindSkeleton","addAnimations","createAmbientLight","node","buildSkeleton","createCamera","createLight","createMesh","createCurve","PropertyBinding","sanitizeNodeName","setModelTransforms","bone","subBone","Bone","matrixWorld","copy","cameraAttribute","attr","NodeAttribute","Object3D","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","width","innerWidth","height","innerHeight","AspectWidth","AspectHeight","aspect","fov","FieldOfView","focalLength","FocalLength","PerspectiveCamera","setFocalLength","OrthographicCamera","lightAttribute","LightType","intensity","Intensity","CastLightOnObject","distance","FarAttenuationEnd","EnableFarAttenuation","decay","PointLight","DirectionalLight","angle","PI","InnerAngle","penumbra","OuterAngle","max","SpotLight","CastShadows","castShadow","attributes","vertexColors","VertexColors","skinning","SkinnedMesh","Mesh","LineBasicMaterial","linewidth","Line","GlobalSettings","ambientColor","AmbientColor","r","g","b","AmbientLight","lookAtTarget","pos","Lcl_Translation","target","lookAt","enums","RotationOrder","rotation","Lcl_Rotation","quaternion","setFromEuler","Lcl_Scaling","PreRotation","preRotations","Quaternion","premultiply","bindMatrices","parsePoseNodes","geoRelationships","geoConnParent","bind","Skeleton","BindPoseNode","Pose","poseNodes","PoseNode","Array","isArray","poseNode","Node","Matrix","parseAnimations","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","rawClips","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","match","curveNode","curves","rawCurves","animationCurve","times","KeyTime","convertFBXTimeToSeconds","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","z","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","rawStacks","AnimationStack","layer","animations","key","rawClip","clip","addClip","tracks","rawTracks","concat","generateTracks","AnimationClip","T","keys","positionTrack","generateVectorTrack","R","rotationTrack","generateRotationTrack","S","scaleTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","VectorKeyframeTrack","interpolateRotations","euler","quaternionValues","QuaternionKeyframeTrack","prevValue","xIndex","yIndex","zIndex","time","xValue","yValue","zValue","sort","filter","elem","valuesSpan","absoluteSpan","abs","numSubIntervals","step","nextValue","initialTime","timeSpan","interval","nextTime","interpolatedTimes","interpolatedValues","inject","getPrevNode","nodeStack","currentIndent","getCurrentNode","getCurrentProp","currentProp","pushStack","popStack","setCurrentProp","val","currentPropName","text","allNodes","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","parseNodePropertyContinued","property","nodeName","trim","replace","nodeAttrs","attrs","parseNodeAttr","currentNode","contentLine","propName","propValue","parentName","parseNodeSpecialProperty","connProps","rest","append","parseNumberArray","props","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","reader","BinaryReader","skip","version","getUint32","log","endOfContent","parseNode","size","getOffset","endOffset","getUint64","numProperties","propertyListLen","nameLen","getUint8","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getFloat64","getFloat32","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","encoding","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","inflate","Inflate","reader2","decompress","littleEndian","dv","DataView","offset","low","high","nullByte","decodeText","CORRECT","cursor","read","result","num","versionRegExp","a1","a2"],"mappings":"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","sourcesContent":["const THREE = require('three');\nvar Zlib = require('./inflate.min').Zlib;\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nmodule.exports = ( function () {\n\n\tTHREE.FBXLoader = function ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t};\n\n\tObject.assign( THREE.FBXLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar resourceDirectory = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar scene = self.parse( buffer, resourceDirectory );\n\t\t\t\t\tonLoad( scene );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\twindow.setTimeout( function () {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tself.manager.itemError( url );\n\n\t\t\t\t\t}, 0 );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, resourceDirectory ) {\n\n\t\t\tvar FBXTree;\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tFBXTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tFBXTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( FBXTree );\n\n\t\t\tvar connections = parseConnections( FBXTree );\n\t\t\tvar images = parseImages( FBXTree );\n\t\t\tvar textures = parseTextures( FBXTree, new THREE.TextureLoader( this.manager ).setPath( resourceDirectory ), images, connections );\n\t\t\tvar materials = parseMaterials( FBXTree, textures, connections );\n\t\t\tvar deformers = parseDeformers( FBXTree, connections );\n\t\t\tvar geometryMap = parseGeometries( FBXTree, connections, deformers );\n\t\t\tvar sceneGraph = parseScene( FBXTree, connections, deformers.skeletons, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t}\n\n\t} );\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tfunction parseConnections( FBXTree ) {\n\n\t\tvar connectionMap = new Map();\n\n\t\tif ( 'Connections' in FBXTree ) {\n\n\t\t\tvar rawConnections = FBXTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tfunction parseImages( FBXTree ) {\n\n\t\tvar images = {};\n\t\tvar blobs = {};\n\n\t\tif ( 'Video' in FBXTree.Objects ) {\n\n\t\t\tvar videoNodes = FBXTree.Objects.Video;\n\n\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tvar image = parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var id in images ) {\n\n\t\t\tvar filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tfunction parseImage( videoNode ) {\n\n\t\tvar content = videoNode.Content;\n\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tvar type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n \t\t\tcase 'tga':\n\n\t\t\t\tif ( typeof THREE.TGALoader !== 'function' ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: THREE.TGALoader is required to load TGA textures' );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( THREE.Loader.Handlers.get( '.tga' ) === null ) {\n\n\t\t\t\t\t\tTHREE.Loader.Handlers.add( /\\.tga$/i, new THREE.TGALoader() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tvar array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tfunction parseTextures( FBXTree, loader, images, connections ) {\n\n\t\tvar textureMap = new Map();\n\n\t\tif ( 'Texture' in FBXTree.Objects ) {\n\n\t\t\tvar textureNodes = FBXTree.Objects.Texture;\n\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\tvar texture = parseTexture( textureNodes[ nodeID ], loader, images, connections );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tfunction parseTexture( textureNode, loader, images, connections ) {\n\n\t\tvar texture = loadTexture( textureNode, loader, images, connections );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\tfunction loadTexture( textureNode, loader, images, connections ) {\n\n\t\tvar fileName;\n\n\t\tvar currentPath = loader.path;\n\n\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tloader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar texture;\n\n\t\tif ( textureNode.FileName.slice( -3 ).toLowerCase() === 'tga' ) {\n\n \t\t\ttexture = THREE.Loader.Handlers.get( '.tga' ).load( fileName );\n\n \t\t} else {\n\n \t\t\ttexture = loader.load( fileName );\n\n \t\t}\n\n\t\tloader.setPath( currentPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tfunction parseMaterials( FBXTree, textureMap, connections ) {\n\n\t\tvar materialMap = new Map();\n\n\t\tif ( 'Material' in FBXTree.Objects ) {\n\n\t\t\tvar materialNodes = FBXTree.Objects.Material;\n\n\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\tvar material = parseMaterial( FBXTree, materialNodes[ nodeID ], textureMap, connections );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tfunction parseMaterial( FBXTree, materialNode, textureMap, connections ) {\n\n\t\tvar ID = materialNode.id;\n\t\tvar name = materialNode.attrName;\n\t\tvar type = materialNode.ShadingModel;\n\n\t\t//Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tvar parameters = parseParameters( FBXTree, materialNode, textureMap, ID, connections );\n\n\t\tvar material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0x3300ff } );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tfunction parseParameters( FBXTree, properties, textureMap, ID, connections ) {\n\n\t\tvar parameters = {};\n\n\t\tif ( properties.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\n\t\t}\n\t\tif ( properties.Diffuse ) {\n\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.Diffuse.value );\n\n\t\t} else if ( properties.DiffuseColor && properties.DiffuseColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in properties.Diffuse\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.DiffuseColor.value );\n\n\t\t}\n\t\tif ( properties.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\n\t\t}\n\t\tif ( properties.Emissive ) {\n\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.Emissive.value );\n\n\t\t} else if ( properties.EmissiveColor && properties.EmissiveColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in properties.Emissive\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.EmissiveColor.value );\n\n\t\t}\n\t\tif ( properties.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( properties.EmissiveFactor.value );\n\n\t\t}\n\t\tif ( properties.Opacity ) {\n\n\t\t\tparameters.opacity = parseFloat( properties.Opacity.value );\n\n\t\t}\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\t\tif ( properties.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\n\t\t}\n\t\tif ( properties.Shininess ) {\n\n\t\t\tparameters.shininess = properties.Shininess.value;\n\n\t\t}\n\t\tif ( properties.Specular ) {\n\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.Specular.value );\n\n\t\t} else if ( properties.SpecularColor && properties.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in properties.Specular\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.SpecularColor.value );\n\n\t\t}\n\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tvar type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = textureMap.get( child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tparameters.map = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tparameters.normalMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tparameters.alphaMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tfunction getTexture( FBXTree, textureMap, id, connections ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tfunction parseDeformers( FBXTree, connections ) {\n\n\t\tvar skeletons = {};\n\t\tvar morphTargets = {};\n\n\t\tif ( 'Deformer' in FBXTree.Objects ) {\n\n\t\t\tvar DeformerNodes = FBXTree.Objects.Deformer;\n\n\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tvar skeleton = parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = parseMorphTargets( relationships, deformerNode, DeformerNodes, connections, FBXTree );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\t\t\t\t\tmorphTarget.parentGeoID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tfunction parseSkeleton( connections, deformerNodes ) {\n\n\t\tvar rawBones = [];\n\n\t\tconnections.children.forEach( function ( child ) {\n\n\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tvar rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\ttransformLink: new THREE.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\tlinkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tfunction parseMorphTargets( relationships, deformerNode, deformerNodes, connections ) {\n\n\t\tvar rawMorphTargets = [];\n\n\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tif ( i === 8 ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.' );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar child = relationships.children[ i ];\n\n\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tvar rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\tvar targetRelationships = connections.get( parseInt( child.ID ) );\n\n\t\t\ttargetRelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'DeformPercent' ) {\n\n\t\t\t\t\t// TODO: animation of morph targets is currently unsupported\n\t\t\t\t\trawMorphTarget.weightCurveID = child.ID;\n\t\t\t\t\t// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\trawMorphTarget.geoID = child.ID;\n\t\t\t\t\t// morphGeo = FBXTree.Objects.Geometry[ geoID ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tfunction parseGeometries( FBXTree, connections, deformers ) {\n\n\t\tvar geometryMap = new Map();\n\n\t\tif ( 'Geometry' in FBXTree.Objects ) {\n\n\t\t\tvar geoNodes = FBXTree.Objects.Geometry;\n\n\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tvar geo = parseGeometry( FBXTree, relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tfunction parseGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn parseMeshGeometry( FBXTree, relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tfunction parseMeshGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tvar skeletons = deformers.skeletons;\n\t\tvar morphTargets = deformers.morphTargets;\n\n\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn FBXTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\tvar morphTarget = relationships.children.reduce( function ( morphTarget, child ) {\n\n\t\t\tif ( morphTargets[ child.ID ] !== undefined ) morphTarget = morphTargets[ child.ID ];\n\n\t\t\treturn morphTarget;\n\n\t\t}, null );\n\n\t\tvar preTransform = new THREE.Matrix4();\n\n\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\n\t\t// different geometric transforms, then this will cause problems\n\t\t// if ( modelNodes.length > 1 ) { }\n\n\t\t// For now just assume one model and get the preRotations from that\n\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\tif ( 'GeometricRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.GeometricRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tpreTransform.makeRotationFromEuler( new THREE.Euler().fromArray( array ) );\n\n\t\t}\n\n\t\tif ( 'GeometricTranslation' in modelNode ) {\n\n\t\t\tpreTransform.setPosition( new THREE.Vector3().fromArray( modelNode.GeometricTranslation.value ) );\n\n\t\t}\n\n\t\tif ( 'GeometricScaling' in modelNode ) {\n\n\t\t\tpreTransform.scale( new THREE.Vector3().fromArray( modelNode.GeometricScaling.value ) );\n\n\t\t}\n\n\t\treturn genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform );\n\n\t}\n\n\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\tfunction genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform ) {\n\n\t\tvar geo = new THREE.BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tvar geoInfo = getGeoInfo( geoNode, skeleton );\n\n\t\tvar buffers = genBuffers( geoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tgeo.addAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.addAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.addAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n\t\t\tnormalMatrix.applyToBufferAttribute( normalAttribute );\n\n\t\t\tgeo.addAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tname = 'uv';\n\n\t\t\t}\n\n\t\t\tgeo.addAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tvar startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\taddMorphTargets( FBXTree, geo, geoNode, morphTarget, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tfunction getGeoInfo( geoNode, skeleton ) {\n\n\t\tvar geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = getColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = getMaterials( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = getNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tgeoInfo.uv.push( getUVs( geoNode.LayerElementUV[ i ] ) );\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tfunction genBuffers( geoInfo ) {\n\n\t\tvar buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tvar polygonIndex = 0;\n\t\tvar faceLength = 0;\n\t\tvar displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tvar facePositionIndexes = [];\n\t\tvar faceNormals = [];\n\t\tvar faceColors = [];\n\t\tvar faceUVs = [];\n\t\tvar faceWeights = [];\n\t\tvar faceWeightIndices = [];\n\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tvar endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tvar weightIndices = [];\n\t\t\tvar weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tfunction genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction addMorphTargets( FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform ) {\n\n\t\tif ( morphTarget === null ) return;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\tparentGeo.morphAttributes.normal = [];\n\n\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\tvar morphGeoNode = FBXTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tfunction genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform ) {\n\n\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\tif ( morphGeoNode.attrName ) morphGeo.name = morphGeoNode.attrName;\n\n\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t// make a copy of the parent's vertex positions\n\t\tvar vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\tvar morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\tvertexPositions[ morphIndex ] += morphPositions[ i * 3 ];\n\t\t\tvertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];\n\t\t\tvertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tvar morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: vertexPositions,\n\t\t};\n\n\t\tvar morphBuffers = genBuffers( morphGeoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = morphGeoNode.attrName;\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tfunction getNormals( NormalNode ) {\n\n\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\tvar buffer = NormalNode.Normals.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tfunction getUVs( UVNode ) {\n\n\t\tvar mappingType = UVNode.MappingInformationType;\n\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\tvar buffer = UVNode.UV.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tfunction getColors( ColorNode ) {\n\n\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\tvar buffer = ColorNode.Colors.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tfunction getMaterials( MaterialNode ) {\n\n\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tvar materialIndices = [];\n\n\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\tvar dataArray = [];\n\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tfunction parseNurbsGeometry( geoNode ) {\n\n\t\tif ( THREE.NURBSCurve === undefined ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar degree = order - 1;\n\n\t\tvar knots = geoNode.KnotVector.a;\n\t\tvar controlPoints = [];\n\t\tvar pointsValues = geoNode.Points.a;\n\n\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tvar startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t} );\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\t// create the main THREE.Group() to be returned by the loader\n\tfunction parseScene( FBXTree, connections, skeletons, geometryMap, materialMap ) {\n\n\t\tvar sceneGraph = new THREE.Group();\n\n\t\tvar modelMap = parseModels( FBXTree, skeletons, geometryMap, materialMap, connections );\n\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\tsetLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph );\n\n\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tbindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections );\n\n\t\taddAnimations( FBXTree, connections, sceneGraph );\n\n\t\tcreateAmbientLight( FBXTree, sceneGraph );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tfunction parseModels( FBXTree, skeletons, geometryMap, materialMap, connections ) {\n\n\t\tvar modelMap = new Map();\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\tvar id = parseInt( nodeID );\n\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\tvar relationships = connections.get( id );\n\n\t\t\tvar model = buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = createCamera( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = createLight( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = createMesh( FBXTree, relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName( node.attrName );\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tsetModelTransforms( FBXTree, model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tfunction buildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tvar bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName( name );\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\tfunction createCamera( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tvar nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tvar farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tvar width = window.innerWidth;\n\t\t\tvar height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tvar aspect = width / height;\n\n\t\t\tvar fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tmodel = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\tfunction createLight( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tvar color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = new THREE.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t}\n\n\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tvar distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tvar decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = THREE.Math.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = THREE.Math.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createMesh( FBXTree, relationships, geometryMap, materialMap ) {\n\n\t\tvar model;\n\t\tvar geometry = null;\n\t\tvar material = null;\n\t\tvar materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.skinning = true;\n\n\t\t\t} );\n\n\t\t\tmodel = new THREE.SkinnedMesh( geometry, material );\n\n\t\t} else {\n\n\t\t\tmodel = new THREE.Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createCurve( relationships, geometryMap ) {\n\n\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\treturn new THREE.Line( geometry, material );\n\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tfunction createAmbientLight( FBXTree, sceneGraph ) {\n\n\t\tif ( 'GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings ) {\n\n\t\t\tvar ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n\t\t\tvar r = ambientColor[ 0 ];\n\t\t\tvar g = ambientColor[ 1 ];\n\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\tvar color = new THREE.Color( r, g, b );\n\t\t\t\tsceneGraph.add( new THREE.AmbientLight( color, 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new THREE.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// parse the model node for transform details and apply them to the model\n\tfunction setModelTransforms( FBXTree, model, modelNode ) {\n\n\t\t// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tif ( 'RotationOrder' in modelNode ) {\n\n\t\t\tvar enums = [\n\t\t\t\t'XYZ', // default\n\t\t\t\t'XZY',\n\t\t\t\t'YZX',\n\t\t\t\t'ZXY',\n\t\t\t\t'YXZ',\n\t\t\t\t'ZYX',\n\t\t\t\t'SphericXYZ',\n\t\t\t];\n\n\t\t\tvar value = parseInt( modelNode.RotationOrder.value, 10 );\n\n\t\t\tif ( value > 0 && value < 6 ) {\n\n\t\t\t\t// model.rotation.order = enums[ value ];\n\n\t\t\t\t// Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[ value ] );\n\n\t\t\t} else if ( value === 6 ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( 'Lcl_Translation' in modelNode ) {\n\n\t\t\tmodel.position.fromArray( modelNode.Lcl_Translation.value );\n\n\t\t}\n\n\t\tif ( 'Lcl_Rotation' in modelNode ) {\n\n\t\t\tvar rotation = modelNode.Lcl_Rotation.value.map( THREE.Math.degToRad );\n\t\t\trotation.push( 'ZYX' );\n\t\t\tmodel.quaternion.setFromEuler( new THREE.Euler().fromArray( rotation ) );\n\n\t\t}\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) {\n\n\t\t\tmodel.scale.fromArray( modelNode.Lcl_Scaling.value );\n\n\t\t}\n\n\t\tif ( 'PreRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.PreRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tvar preRotations = new THREE.Euler().fromArray( array );\n\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\t\t\tmodel.quaternion.premultiply( preRotations );\n\n\t\t}\n\n\t}\n\n\tfunction bindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections ) {\n\n\t\tvar bindMatrices = parsePoseNodes( FBXTree );\n\n\t\tfor ( var ID in skeletons ) {\n\n\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new THREE.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tfunction parsePoseNodes( FBXTree ) {\n\n\t\tvar bindMatrices = {};\n\n\t\tif ( 'Pose' in FBXTree.Objects ) {\n\n\t\t\tvar BindPoseNode = FBXTree.Objects.Pose;\n\n\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\tfunction parseAnimations( FBXTree, connections ) {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( FBXTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tvar curveNodesMap = parseAnimationCurveNodes( FBXTree );\n\n\t\tparseAnimationCurves( FBXTree, connections, curveNodesMap );\n\n\t\tvar layersMap = parseAnimationLayers( FBXTree, connections, curveNodesMap );\n\t\tvar rawClips = parseAnimStacks( FBXTree, connections, layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tfunction parseAnimationCurveNodes( FBXTree ) {\n\n\t\tvar rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n\n\t\tvar curveNodesMap = new Map();\n\n\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T/ ) !== null ) {\n\n\t\t\t\tvar curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tfunction parseAnimationCurves( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawCurves = FBXTree.Objects.AnimationCurve;\n\n\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\tvar animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tfunction parseAnimationLayers( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawLayers = FBXTree.Objects.AnimationLayer;\n\n\t\tvar layersMap = new Map();\n\n\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\tvar layerCurveNodes = [];\n\n\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tvar children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tvar modelID;\n\n\t\t\t\t\t\t\t\tconnections.get( child.ID ).parents.forEach( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\tif ( parent.relationship !== undefined ) modelID = parent.ID;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\tvar rawModel = FBXTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ),\n\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Translation' in rawModel ) node.initialPosition = rawModel.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Rotation' in rawModel ) node.initialRotation = rawModel.Lcl_Rotation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Scaling' in rawModel ) node.initialScale = rawModel.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotations = rawModel.PreRotation.value;\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\tfunction parseAnimStacks( FBXTree, connections, layersMap ) {\n\n\t\tvar rawStacks = FBXTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tvar rawClips = {};\n\n\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\t// take raw animation data from parseAnimations and connect it up to the loaded models\n\tfunction addAnimations( FBXTree, connections, sceneGraph ) {\n\n\t\tsceneGraph.animations = [];\n\n\t\tvar rawClips = parseAnimations( FBXTree, connections );\n\n\t\tif ( rawClips === undefined ) return;\n\n\n\t\tfor ( var key in rawClips ) {\n\n\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\tvar clip = addClip( rawClip );\n\n\t\t\tsceneGraph.animations.push( clip );\n\n\t\t}\n\n\t}\n\n\tfunction addClip( rawClip ) {\n\n\t\tvar tracks = [];\n\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new THREE.AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tfunction generateTracks( rawTracks ) {\n\n\t\tvar tracks = [];\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tvar positionTrack = generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tvar rotationTrack = generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tvar scaleTrack = generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tfunction generateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new THREE.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tfunction generateRotationTrack( modelName, curves, initialValue, preRotations ) {\n\n\t\tif ( curves.x !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.x );\n\t\t\tcurves.x.values = curves.x.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.y !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.y );\n\t\t\tcurves.y.values = curves.y.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.z !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.z );\n\t\t\tcurves.z.values = curves.z.values.map( THREE.Math.degToRad );\n\n\t\t}\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\tif ( preRotations !== undefined ) {\n\n\t\t\tpreRotations = preRotations.map( THREE.Math.degToRad );\n\t\t\tpreRotations.push( 'ZYX' );\n\n\t\t\tpreRotations = new THREE.Euler().fromArray( preRotations );\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\n\t\t}\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar quaternionValues = [];\n\n\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], 'ZYX' );\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotations !== undefined )quaternion.premultiply( preRotations );\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new THREE.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tfunction getKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tvar prevValue = initialValue;\n\n\t\tvar values = [];\n\n\t\tvar xIndex = - 1;\n\t\tvar yIndex = - 1;\n\t\tvar zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tfunction getTimesForAllAxes( curves ) {\n\n\t\tvar times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them and remove duplicates\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} ).filter( function ( elem, index, array ) {\n\n\t\t\treturn array.indexOf( elem ) == index;\n\n\t\t} );\n\n\t\treturn times;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tfunction interpolateRotations( curve ) {\n\n\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\tnextValue += step;\n\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tObject.assign( TextParser.prototype, {\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar self = this;\n\n\t\t\tvar split = text.split( '\\n' );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tself.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tself.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t} );\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tObject.assign( BinaryParser.prototype, {\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tconsole.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tObject.assign( BinaryReader.prototype, {\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\tvar a = new Uint8Array( size );\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn THREE.LoaderUtils.decodeText( a );\n\n\t\t}\n\n\t} );\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tObject.assign( FBXTree.prototype, {\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t} );\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn THREE.FBXLoader\n\n} )();\n"]},"metadata":{},"sourceType":"script"}